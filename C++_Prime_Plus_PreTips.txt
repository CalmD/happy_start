# happy_start
start up

C++ 基础小Tips

1.一个字节的数值的二进制补码表示中，1111 1111 表示-1，1111 1110 表示-2（-1-1），最小的负值是1000 0000（-128）.【负数补码是原码取反加1】
2.对于任何一种进制的整数，若有后缀字母u（或U）/后缀l（或L），则系统强制规定它是一个无符号（unsigned int）/长整型（long int）数。
3.运算符的左/右结合性表示操作数优先与左边/右边的运算符进行计算。
4.#pragma comment(lib, "iphlpapi.lib")
	该语句是预编译指令，它告诉编译器在编译形成的.obj文件和.exe文件中插入一条注释，该注释传递给连接器，使得它在连接库的时候去找iphlpapi.lib这个库文件。
5.cout<< ... << hex << ... << endl;
	语句中的hex为格式控制符，表示之后的输出均采用十六进制的形式显示，该格式直到遇到表示其他进制形式显示的格式控制符为止。（dec、oct）
6.重载函数是通过函数的形参列表来唯一标识区分的一种特殊函数。需满足条件：函数名相同；形参个数、形参类型或形参顺序中至少一种不同。
7.带默认参数的函数，遵循的原则是实参的值只能按照从左至右的顺序依次赋给形参，所以声明带默认参数的函数中的形参的默认值只能按照从右至左的方向指定。
	int add(int x, int y=20, int z=10);
8.一个函数不能既作为重载函数，又作为带默认参数的函数，因为这样会引起二义性，系统无法判断是利用重载函数还是利用带默认参数的函数。
9.并非一指定为inline函数，编译系统就一定按内联函数执行，除非被指定的函数符合内联函数体的要求，否则就会将其作为一般的函数调用。
10.静态局部变量的初始赋值是在程序编译期间进行的，即只需要赋值一次，以后就不再重新赋初值。
11.预处理命令不是C++语句，所以行尾不叫分号。
12.C++为了更方便地使用字符串，在标准库中声明了一种string类型的数据类型，该类型支持长度可变的字符串，如果想使用标准C++中的string类，需要包含string头文件。
	cstring头文件（或string.h）中主要是跟字符数组有关的处理，而string头文件是有关string类型的定义与操作。
13.getline(cin, 对象名)
	getline函数可以读取整行文本。它和cin语句的区别在于，getline读入一行数据，直到回车才认为字符串结束，而cin语句碰到空白符即认为读入字符串结束。
14.在string对象间可以进行连接操作“+”,即将两个字符串连接在一起，形成更长的字符串。
	string a, b, c;
	c=a+b;
15.无名变量（即通过运算符new动态创建一个没有标识符的变量）
	int *pint = new int（10）；
	对于这些无名变量，只能通过指针来进行间接访问。
	new返回的是指向新变量的指针。
	可以在动态创建的同时指定初始化列表。
16.引用
	在声明引用的同时必须指定对哪个变量的引用，即对其进行初始化。
	不能建立数组的引用，因为数组是若干个元素组成的集合，所以无法建立一个数组的别名。
	使用引用传递函数的参数在内存中并没有产生实参的副本，它是直接对实参操作。
17.常引用	int a；const int &b=a；
	对于这种方式声明的引用，不能通过引用对目标变量的值进行修改。
	当函数的引用参数是常引用时，在被调用函数的内部不能修改常引用的值。
18.引用作为函数返回值
	类型标识符 & 函数名（形参列表）
	{
		函数体
	}
	用引用返回一个函数值的最大好处是在内存中不产生被返回值的副本。
	引用作为返回值须遵守：
	1）不能返回局部变量的引用。因为局部变量在函数返回后被销毁。
	2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量自动销毁问题，但返回函数内部new分配内存的引用，因为被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间就无法释放，造成memory leak。
	3）可以返回类成员的引用，但最好是const。
19.申请动态数组
	数据类型 *parr = new 数据类型[n];
	释放 delete []parr;
20.string 初始化
	可以使用单个字符和长度初始化成由单个字符组成的长度为指定值的字符串。
	string 对象名（长度，字符）;
	string e(5, 'a');